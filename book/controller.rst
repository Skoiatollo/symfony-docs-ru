.. index::
   single: Контроллер

Контроллер
==========

Контроллер - это PHP-функция, которую вы создаёте и которая получает
информацию из HTTP запроса и конструирует и возвращает HTTP ответ (в виде
объекта ``Response`` в Symfony2). Ответ может быть HTML страницей, XML-документом,
сериализованным JSON-массивом, изображением, перенаправлением, ошибкой 404,или
всем, чем захотите. Контроллер содержит субъективную
логику *вашего приложения*, необходимую для того, чтобы отобразить содержимое
страницы.

Для того, чтобы увидеть, насколько просто этого можно добиться, давайте рассмотрим
контроллер Symfony2 в действии. Следующий контроллер отобразит страницу, которая
всего-навсего напечатает ``Hello world!``::

    use Symfony\Component\HttpFoundation\Response;

    public function helloAction()
    {
        return new Response('Hello world!');
    }

Цель у контроллера всегда одна: создать и вернуть объект ``Response``. Следуя
этой цели, контроллер может читать информацию из запроса, загружать ресурсы из
базы данных, отправлять email или же записывать информациюю в сессию пользователя.
Но всегда, в конечном итоге, контроллер вернёт объект ``Response``, который
будет отправлен обратно клиенту.

Здесь нет никакой магии или других требований, о которых стоило бы беспокоиться!
Вот несколько типичных примеров:

* *Контроллер A* создаёт объект ``Response``, содержащий контент для главной страницы сайта.

* *Контроллер B* получает из запроса параметр ``slug`` для того, чтобы загрузить
  запись блога из базы данных и создать объект ``Response``, отображающий
  этот блог. Если указанный ``slug`` не может быть найден в базе, он создаёт
  и возвращает объект ``Response`` со статус-кодом 404.

* *Контроллер C* обрабатывает отправленную форму контактов. Он читает информацию о форме
  из запроса, сохраняет контактную информацию в базу данных и отправляет сообщение с
  контактной информацией вебмастеру. Наконец, он создаёт объект ``Response``, который 
  перенаправляет браузер клиента на страницу "thank you" формы контактов.

.. index::
   single: Контроллер; Жизненный цикл Запрос-Контроллер-Ответ

Жизненный цикл Запрос-Контроллер-Ответ
--------------------------------------

Каждый запрос, обрабатываемый проектом Symfony2, следует одному и тому же простому
жизненному циклу. Фреймворк берёт на себя повторяющиеся задачи и, в конце концов
выполняет контроллер, который содержит код вашего приложения:

#. Каждый запрос обрабатывается одним файлом с фронт-контроллером (например ``app.php``
   или ``app_dev.php``), который загружает приложение;

#. ``Router`` читает информацию из запроса (URI к примеру), ищет маршрут,подходящий 
   для этой информации, и получает параметр ``_controller`` из маршрута;

#. Контроллер, соответствующий маршруту, выполняется, и  код внутри контроллера создает
   и возвращает объект ``Response``;

#. HTTP-заголовки и контент объекта ``Response`` отправляются обратно клиенту.

Создание страницы - это по сути создание контроллера (#3) и маршрута, который ставит
в соответствие контроллеру некий URL (#2).

.. note::

    Не смотря на то что "фронт-контроллер" и "контроллер" названы похожим
    образом, они сильно различаются - об этом мы еще поговорим
    чуть позже в этой главе. Фронт-контроллер - это короткий PHP-файл, который
    находится в web-директории и который обрабатывает все входящие запросы.
    Типичное приложение имеет продуктовый фронт-контроллер (``prod``, как правило ``app.php``)
    и контроллер для разработки (``dev``, как правило ``app_dev.php``). И вам
    скорее всего никогда не придется модифицировать, просматривать или вообще задумываться
    о фронт-контроллерах в вашем приложении.

.. index::
   single: Контроллер; Простой пример

Простой контроллер
------------------

В то время как контроллер может быть любой PHP-сущностью, которую можно вызвать (функцией,
методом объекта, или же замыканием (``Closure``)), в Symfony2 контроллер - это как правило
некий метод объекта контроллера. Контроллеры также называются *действиями* (actions).

.. code-block:: php
    :linenos:

    // src/Acme/HelloBundle/Controller/HelloController.php
    namespace Acme\HelloBundle\Controller;

    use Symfony\Component\HttpFoundation\Response;

    class HelloController
    {
        public function indexAction($name)
        {
            return new Response('<html><body>Hello '.$name.'!</body></html>');
        }
    }

.. tip::

    Обратите внимание, что *контроллер* - это метод ``indexAction``,
    который расположен внутри *класса контроллера* (``HelloController``).
    Смотрите не путайтесь: *класс контроллера* - это просто удобный способ
    сгруппировать несколько контроллеров/действий вместе. Обычно класс
    контроллера содержит несколько контроллеров/действий (например
    ``updateAction``, ``deleteAction`` и т.д.).

В этом контроллере нет ничего сложного:

* *строка 4*: Symfony2 использует преимущества пространств имён PHP 5.3 для
  поименования целого класса контроллеров. Ключевое слово  ``use`` импортирует 
  класс ``Response``, который контроллер должен вернуть.

* *строка 6*: Имя класса это результат объединения имени контроллера (``Hello``)
  и слова ``Controller``. Это очередная договорённость, которая позволяет обеспечить
  единообразие в именовании контроллеров и позволяет ссылаться на класс только по
  первой части наименования (здесь это будет ``Hello``) в конфигурации маршрутизатора.

* *line 8*: Каждое действие в классе контроллера имеет суффикс ``Action`` и
  упоминается в настройках маршрутизатора только по имени действия(``index``).
  В следующей разделе вы создадите маршрут, который привяжет URI к
  этому действию. Вы узнаете, как заполнитель для имени в маршруте - ``{name}`` -
  станет аргументом метода действия (``$name``).

* *line 10*: Контроллер создаёт и возвращает объект ``Response``.

.. index::
   single: Контроллер; Маршруты и контроллеры

Соответствие URL Контроллеру
----------------------------

Новый контроллер возвращает простую HTML-страницу. Для того, чтобы увидеть эту
страницу в вашем браузере, вам надо создать маршрут, который устанавливает
соответствие между некоторым URL и контроллером:

.. configuration-block::

    .. code-block:: yaml

        # app/config/routing.yml
        hello:
            path:      /hello/{name}
            defaults:  { _controller: AcmeHelloBundle:Hello:index }

    .. code-block:: xml

        <!-- app/config/routing.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                http://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="hello" path="/hello/{name}">
                <default key="_controller">AcmeHelloBundle:Hello:index</default>
            </route>
        </routes>

    .. code-block:: php

        // app/config/routing.php
        $collection->add('hello', new Route('/hello/{name}', array(
            '_controller' => 'AcmeHelloBundle:Hello:index',
        )));

Теперь при запросе URI ``/hello/ryan`` теперь выполняется контроллер
``HelloController::indexAction()`` и присваивает переменной ``$name``
значение ``ryan``. Создание страницы по сути подразумевает всего лишь
создание метода контроллера и соответствующего маршрута.

Обратите внимание на синтаксис, при помощи которого маршрут ссылается
на контроллер: ``AcmeHelloBundle:Hello:index``. Symfony2 использует гибкую
строковую нотацию для создания ссылок на различные контроллеры. Этот самый
обычный синтаксис сообщает Symfony2 что класс контроллера с именем
``HelloController`` расположен в пакете ``AcmeHelloBundle``. Затем
выполняется метод ``indexAction()``.

Более подробно о формате строк, используемых для создания ссылок на различные
контроллеры, можно почитать здесь: :ref:`controller-string-syntax`.

.. note::

    В этом примере конфигурация маршрутизатора выполняется непосредственно
    в директории ``app/config/``. На практике более удобен способ, когда ваши
    маршруты размещаются в пакете, которому соответствуют. Более подробно этот
    способ рассматривается здесь: :ref:`routing-include-external-resources`.

.. tip::

    Подробно вопросы маршрутизации рассматриваются в главе :doc:`Маршрутизация</book/routing>`.

.. index::
   single: Контроллер; Аргументы контроллера

.. _route-parameters-controller-arguments:

Параметры маршрута в качестве аргументов Контроллера
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Вы уже знаете, что параметр ``_controller`` со значением ``AcmeHelloBundle:Hello:index``
ссылается на метод ``HelloController::indexAction()``, который расположен в пакете
``AcmeHelloBundle``. Также интерес представляют аргументы, которые передаются в этот
метод::

    // src/Acme/HelloBundle/Controller/HelloController.php
    namespace Acme\HelloBundle\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\Controller;

    class HelloController extends Controller
    {
        public function indexAction($name)
        {
          // ...
        }
    }

Контроллер имеет единственный аргумент - ``$name``, который соответствует
параметру ``{name}`` из совпавшего маршрута (в нашем примере - ``ryan``). Фактически,
когда ваш контроллер выполняется, Symfony2 каждому аргументу контроллера ставит
в соответствие параметр из совпавшего маршрута. Взгляните на пример:

.. configuration-block::

    .. code-block:: yaml

        # app/config/routing.yml
        hello:
            path:      /hello/{firstName}/{lastName}
            defaults:  { _controller: AcmeHelloBundle:Hello:index, color: green }

    .. code-block:: xml

        <!-- app/config/routing.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                http://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="hello" path="/hello/{firstName}/{lastName}">
                <default key="_controller">AcmeHelloBundle:Hello:index</default>
                <default key="color">green</default>
            </route>
        </routes>

    .. code-block:: php

        // app/config/routing.php
        $collection->add('hello', new Route('/hello/{firstName}/{lastName}', array(
            '_controller' => 'AcmeHelloBundle:Hello:index',
            'color'       => 'green',
        )));

Контроллер для этого примера принимает несколько аргументов::

    public function indexAction($firstName, $lastName, $color)
    {
        // ...
    }

Обратите внимание, что оба заполнителя для переменных (``{first_name}``,
``{last_name}``), как и переменная по умолчанию ``color`` - доступны
в качестве аргументов в контроллере. Когда совпадает маршрут, заполнители
переменных объединяются с ``defaults`` в один массив, который становится доступен
вашему контроллеру.

Настройка соответствия параметров маршрута аргументам контроллера проста и гибка, нужно
лишь следовать нижеперечисленным рекомендациям во время разработки:

* **Порядок аргументов контроллера не имеет значения**

    Symfony в состоянии установить соответствие между именами параметров
    маршрута и сигнатурой метода в контроллере. Другими словами, это работает
    таким образом, что параметр ``{last_name}`` соответствует аргументу
    ``$last_name``. Аргументы контроллера можно поменять местами и он всё равно
    будет работать::

        public function indexAction($lastName, $color, $firstName)
        {
            // ...
        }

* **Каждый обязательный аргумент контроллера должен соответствовать параметру маршрута**

    Следующий пример вызовет исключение ``RuntimeException``, так как в маршруте
    не определён параметр ``foo``::

        public function indexAction($firstName, $lastName, $color, $foo)
        {
            // ...
        }

    Для того чтобы это работало, нужно сделать параметр опциональным. Следующий
    пример не будет вызывать исключительной ситуации:

    .. code-block:: php

        <?php
        public function indexAction($first_name, $last_name, $color, $foo = 'bar')
        {
            // ..
        }

* **Обратите внимание, что параметры маршрута не обязательно должны быть представлены в виде аргументов контроллера**

    Если, к примеру, параметр ``last_name`` не нужен в контроллере, его можно
    опустить::

        public function indexAction($firstName, $color)
        {
            // ...
        }

.. tip::

    Каждый маршрут имеет специализировнный параметр ``_route``, который
    содержит значение равное его имени (например ``hello``). Обычно это значение
    не используется, но, тем не менее, этот параметр также доступен в качестве
    аргумента контроллера.

.. _book-controller-request-argument:

``Request`` как аргумент Контроллера
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для большего удобства, Symfony также может передать объект ``Request`` в качестве
аргумента в ваш контроллер. Это особенно удобно при работе с формами, например::

    use Symfony\Component\HttpFoundation\Request;

    public function updateAction(Request $request)
    {
        $form = $this->createForm(...);

        $form->handleRequest($request);
        // ...
    }

.. index::
   single: Контроллер; Базовый класс контроллера
   
Создание Статичных Страниц
---------------------

Вы можете создавать статичные страницы, даже не создавая предварительно контроллер (а только маршрут
и шаблон).

Пользуйтесь этим! Смотрите :doc:`/cookbook/templating/render_without_controller`.

Базовый класс контроллера
-------------------------

Для большего удобства, Symfony2 включает базовый класс ``Controller``, который оказывает помощь в
выполнении наиболее типичных задач контроллера и предоставляет вашему контроллеру
доступ к любому ресурсу, который может ему потребоваться. Осуществляя наследование
от класса ``Controller``, вы получите в своё распоряжение некоторое число
методов-помощников.

Добавьте выражение ``use`` в начале класса контроллера и модифицируйте
``HelloController``, чтобы он наследовался от ``Controller``::

    // src/Acme/HelloBundle/Controller/HelloController.php
    namespace Acme\HelloBundle\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\Controller;
    use Symfony\Component\HttpFoundation\Response;

    class HelloController extends Controller
    {
        public function indexAction($name)
        {
            return new Response('<html><body>Hello '.$name.'!</body></html>');
        }
    }

Эти изменения на самом деле ничего не меняют в логике работы вашего контроллера.
В следующем разделе вы узнаете о тех методах-помощниках, которые предоставляет
базовый класс. Эти методы по сути являются обёртками для базового функционала
Symfony2 который доступен вам в любом случае - с использованием базового класса
``Controller`` или же без него. Самый лучший путь для того чтобы увидеть базовые
функции в действии - заглянуть в код класса
:class:`Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller` самостоятельно.

.. tip::

    Наследование от базового класса совершенно *не обязательно* в Symfony; он содержит 
    полезные методы-ярлыки, но они необязательны к использованию. 
    Вы также можете отнаследоваться от 
    :class:`Symfony\\Component\\DependencyInjection\\ContainerAware` или использовать
    trait класса:`Symfony\\Component\\DependencyInjection\\ContainerAwareTrait` 
    (если у вас PHP 5.4). Объект service container'а будет доступен в таком случае через
    свойство ``container``.

.. note::

    Вы также можете объявить контроллер в качестве сервиса:
    :doc:`Controllers as Services </cookbook/controller/service>`. Это необязательно,
    но зато даст вам больший контроль над именно теми зависимостями, которые будут 
    привнесены в ваши контроллеры.

.. index::
   single: Контроллер; Базовые операции

Базовые операции Контроллера
----------------------------

Хотя контроллер может сделать практически что угодно, в основном контроллеры
выполняют одни и те же задачи снова и снова. Эти задачи, такие как перенаправление,
переадресация, отображение шаблона и доступ к основным сервисам, в Symfony2
выполнять очень легко.

.. index::
   single: Контроллер; Перенаправление

Перенаправление (redirecting)
~~~~~~~~~~~

Если вы хотите перенаправить пользователя на другую страницу, используйте метод
``redirect()``::

    public function indexAction()
    {
        return $this->redirect($this->generateUrl('homepage'));
    }

Метод ``generateUrl()``, это всего-лишь функция-помощник, которая генерирует URL
для заданного маршрута. Более подробно этот вопрос рассматривается в главе
:doc:`Маршрутизация </book/routing>`.

По умолчанию, метод ``redirect()`` выполняет перенаправление с HTTP статус-кодом 302
(временное перенаправление). Для того, чтобы выполнить постоянное перенаправление
(со статус-кодом 301), необходимо добавить второй аргумент::

    public function indexAction()
    {
        return $this->redirect($this->generateUrl('homepage'), 301);
    }

.. tip::

    Метод ``redirect()`` - это просто ярлычок для операции создания объекта
    ``Response``, который специализируется на перенаправлении пользователя.
    Он эквивалентен следующему коду::

        use Symfony\Component\HttpFoundation\RedirectResponse;

        return new RedirectResponse($this->generateUrl('homepage'));

.. index::
   single: Контроллер; Переадресация

Контроллер, Переадресация (forwarding)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Вы также легко можете переадресовать запрос на другой контроллер внутри
системы, используя метод 
:method:`Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller::forward`. 
Вместо того, чтобы выполнить перенаправление браузера пользователя, этот метод выполняет внутренний
подзапрос и вызывает указанный контроллер. Метод ``forward()`` возвращает
объект ``Response``, полученный от этого контроллера::

    public function indexAction($name)
    {
        $response = $this->forward('AcmeHelloBundle:Hello:fancy', array(
            'name'  => $name,
            'color' => 'green',
        ));

        // ... внести дальнейшие изменения в ответ или отправить его сейчас

        return $response;
    }

Обратите внимание, что метод `forward()` использует для указания контроллера
тот же формат строки, который используется в конфигурации маршрутов. В данном случае,
класс контроллера - это ``HelloController`` из пакета ``AcmeHelloBundle``.
Массив, передаваемый методу в качестве параметра, будет конвертирован в параметры
целевого контроллера. Такой же интерфейс используется при встраивании контроллеров
в шаблоны (см. :ref:`templating-embedding-controller`). Метод целевого контроллера
должен выглядеть следующим образом::

    public function fancyAction($name, $color)
    {
        // ... создать и вернуть обьект Response 
    }

И, как и в случае создания контроллера для маршрута, порядок аргументов
для ``fancyAction`` не имеет значения. Symfony2 устанавливает соответствие по
именам ключей (например ``name``) и именам параметров (например ``$name``).
Если вы изменяете порядок следования аргументов, Symfony2 также будет присваивать
верные значения каждой переменной.

.. tip::

    Как и прочие методы базового ``Controller``, метод ``forward`` - это просто
    ярлык к базовому функционалу Symfony2. Переадресация может быть выполнена
    напрямую через дублирование текущего запроса.  Потом этот подзапрос 
    (:ref:`sub request <http-kernel-sub-requests>`) выполняется  через сервис ``http_kernel``, 
    и сервис ``HttpKernel`` возвращает  объект ``Response``::

        use Symfony\Component\HttpKernel\HttpKernelInterface;

        $path = array(
            '_controller' => 'AcmeHelloBundle:Hello:fancy',
            'name'        => $name,
            'color'       => 'green',
        );
        $request = $this->container->get('request');
        $subRequest = $request->duplicate(array(), null, $path);

        $httpKernel = $this->container->get('http_kernel');
        $response = $httpKernel->handle($subRequest, HttpKernelInterface::SUB_REQUEST);

.. index::
   single: Контроллер; рендеринг шаблонов

.. _controller-rendering-templates:

Рендеринг Шаблонов
~~~~~~~~~~~~~~~~~~

Хотя это и не является требованием, большинство контроллеров в конце концов
будут отображать (рендерить) шаблон, который отвечает за генерацию HTML (или
данных в другом формате) для контроллера. Метод ``renderView()`` рендерит
шаблон и возвращает его содержимое. Контент из шаблона может быть использован для
создания объекта ``Response``::

    use Symfony\Component\HttpFoundation\Response;

    $content = $this->renderView(
        'AcmeHelloBundle:Hello:index.html.twig',
        array('name' => $name)
    );

    return new Response($content);

Эти операции могут быть выполнены и за один шаг при помощи метода ``render()``,
который возвращает объект ``Response``, содержащий контент шаблона::

    return $this->render(
        'AcmeHelloBundle:Hello:index.html.twig',
        array('name' => $name)
    );

В обоих случаях, будет отображен шаблон ``Resources/views/Hello/index.html.twig`` из
пакета ``AcmeHelloBundle``.

Шаблонизатор Symfony подробно рассматривается в главе о :doc:`Шаблонах </book/templating>`

.. tip::

    Вы даже можете избежать вызова метода ``render``, используя аннотацию ``@Template``.
    Посмотреть детальнее можно в 
    :doc:`FrameworkExtraBundle documentation </bundles/SensioFrameworkExtraBundle/annotations/view>`.
    
.. tip::

    Метод ``renderView`` - это по сути ярлык для быстрого использования шаблонизатора.
    Шаблонизатор также можно использовать напрямую::

        $templating = $this->get('templating');
        $content = $templating->render(
            'AcmeHelloBundle:Hello:index.html.twig',
            array('name' => $name)
        );

.. note::

    Также возможно ренедерить шаблоны в более глубоких подкаталогах, хотя здесь нужно
    стараться избегать типовой ошибки, когда структура каталогов становится слишком разветвленной::
   
        $templating->render(
            'AcmeHelloBundle:Hello/Greetings:index.html.twig',
            array('name' => $name)
        );
        // ренедерится index.html.twig, найденный в Resources/views/Hello/Greetings.


.. index::
   single: Контроллер; Доступ к сервисам

Доступ к сервисам
~~~~~~~~~~~~~~~~~~~~~~~~

При наследовании от базового класса контроллера, вы можете получить доступ к любому
сервису Symfony2 при помощи метода ``get()``. Ниже представлены основные сервисы, которые
вам могут быть полезны::

    $request = $this->getRequest();

    $templating = $this->get('templating');

    $router = $this->get('router');

    $mailer = $this->get('mailer');

В Symfony2 по умолчанию определена куча сервисов и вы вольны определить ещё столько
же собственных. Для того, чтобы отобразить список доступных сервисов, используйте
консольную команду ``container:debug``:

.. code-block:: bash

    php app/console container:debug

Больше данных о сервисах вы можете почерпнуть из главы  :doc:`Service container </book/service_container>`.

.. index::
   single: Контроллер; Разбираемся с ошибками
   single: Контроллер; 404 страница

Разбираемся с ошибками и 404 страница
-------------------------------------

Когда что-либо не может быть найдено, вам следует удовлеворить HTTP протокол, и вернуть статус-код 404.
Для того, чтобы это сделать, вы можете сгенерировать особый тип исключения.
Если вы унаследовали контроллер от базового, выполните следующее::

    public function indexAction()
    {
        // получить объект из базы даннх
        $product = ...;
        if (!$product) {
            throw $this->createNotFoundException('The product does not exist');
        }

        return $this->render(...);
    }

Метод ``createNotFoundException()`` создаёт особый объект ``NotFoundHttpException``,
который в конечном итоге провоцирует внутри Symfony HTTP ответ с  статус-кодом 404.

Конечно, вы вольны вызывать любую исключительную ситуацию в вашем контроллере -
Symfony2 автоматически вернёт HTTP ответ со статус-кодом 500.

.. code-block:: php

    throw new \Exception('Что-то пошло не так!');

В любом случае, пользователь увидит оформленныую стилями страницу с той или иной ошибкой, а
разработчику (при просмотре страницы в режиме отладки) будет показана страница
с полной отладочной информацией по ошибке. Обе эти страницы ошибок могут быть видоизменены.
Более подробно об этом написано в "книге рецептов": ":doc:`/cookbook/controller/error_pages`".

.. index::
   single: Контроллер; Сессии
   single: Session

Работа с Сессиями
--------------------

Symfony2 предоставляет вам объект, для работы с сессиями, который вы можете
использовать для хранения информации о пользователе (если он реальный человек, автоматический бот
или же веб-сервис) между запросами. По умолчанию, Symfony2 сохраняет атрибуты в куках (cookie),
используя нативные сессии PHP.

Сохранение и получение информации из сессии можно использовать из любого
контроллера::

    $session = $this->getRequest()->getSession();

    // сохраняет атрибут для многократного использования во время следующего запроса пользователя
    $session->set('foo', 'bar');

    // в другой контроллер для другого запроса
    $foo = $session->get('foo');

    // использует значение по умолчанию, если ключ не существует xist
    $filters = $session->get('filters', array());

Эти атрибуты будут соответствовать конкретному пользователю, пока существует его
сессия.

.. index::
   single Сессия; Flash-сообщения

Flash-сообщения
~~~~~~~~~~~~~~

Вы также можете сохранять небольшие сообщения, которые сохраняются в пользовательской
сессии между двумя запросами. Эти сообщения удобно использовать при обработке форм:
вы хотите выполнить перенаправление и отобразить особое сообщение при *следующем*
запросе. Такие сообщения называются flash-сообщениями.

Например, представьте, что вы обрабатываете отправку формы::

    public function updateAction()
    {
        $form = $this->createForm(...);

        $form->handleRequest($this->getRequest());

        if ($form->isValid()) {
            // сделать какую-то обработку 

            $this->get('session')->getFlashBag()->add(
                'notice',
                'Ваши изменения сохранены!'
            );

            return $this->redirect($this->generateUrl(...));
        }

        return $this->render(...);
    }

После обработки запроса контроллер устанавливает flash-сообщение ``notice``
и выполняет перенаправление. Имя (``notice``) не устанавливается жёстко - это лишь
обозначение типа сообщения.

В шаблоне следующего действия вы можете использовать следующий код для
отображения сообщения ``notice``:

.. configuration-block::

    .. code-block:: html+jinja

        {% for flashMessage in app.session.flashbag.get('notice') %}
            <div class="flash-notice">
                {{ flashMessage }}
            </div>
        {% endfor %}

    .. code-block:: html+php

        <?php foreach ($view['session']->getFlashBag()->get('notice') as $message): ?>
            <div class="flash-notice">
                <?php echo "<div class='flash-error'>$message</div>" ?>
            </div>
        <?php endforeach; ?>

По умолчанию, flash-сообщения должны жить ровно один запрос. Они разработаны именно
для того, чтобы использоваться во время перенаправлениями так, как показано в этом примере.

.. index::
   single: Контроллер; Объект ответа

Объект Ответа
-------------------

К контроллеру предъявляется лишь одно требование - вернуть объект ``Response``.
Класс :class:`Symfony\\Component\\HttpFoundation\\Response` представляет собой
PHP-абстракцию HTTP-ответа - текстового сообщения, состоящего из HTTP-заголовков и
контента, который возвращается клиенту::

    // создаётся простой объект Response со статус-кодом 200 (по умолчанию)
    $response = new Response('Hello '.$name, Response::HTTP_OK);

    // создаётся JSON-ответ со статус-кодом 2000
    $response = new Response(json_encode(array('name' => $name)));
    $response->headers->set('Content-Type', 'application/json');

.. versionadded:: 2.4
    В Symfony 2.4. была добавлена поддержка констант статус-кода HTTP.


.. tip::

    Свойство ``headers`` - это объект :class:`Symfony\\Component\\HttpFoundation\\HeaderBag`,
    содержащий несколько полезных методов для чтения и изменения заголовков ответа ``Response``.
    Имена заголовков нормализованы, так что ``Content-Type``, ``content-type`` и
    даже ``content_type`` эквивалентны.
    
.. tip::

    есть также особые классы для того, чтобы облегчить создание определенных видов ответов:

    - Для JSON есть класс :class:`Symfony\\Component\\HttpFoundation\\JsonResponse`.
      Смотри :ref:`component-http-foundation-json-response`.
    - Для фалов есть класс :class:`Symfony\\Component\\HttpFoundation\\BinaryFileResponse`.
      Смотри :ref:`component-http-foundation-serving-files`.
    

.. index::
   single: Контроллер; Объект запроса

Объект запроса
------------------

Помимо значений заполнителей из маршрута, контроллер также имеет доступ
к объекту ``Request``, когда он является наследником базового класса ``Controller``::

    $request = $this->getRequest();

    $request->isXmlHttpRequest(); // это запрос Ajax?

    $request->getPreferredLanguage(array('en', 'fr'));

    $request->query->get('page'); // получить параметр $_GET 

    $request->request->get('page'); // получить параметр $_POST 

Подобно объекту ``Response``, заголовки запроса хранятся в объекте ``HeaderBag``
и также легко доступны.

Заключение
--------------

Когда вы создаёте страницу, в конечном итоге должны написать код, который
содержит логику этой страницы. В Symfony эта логика называется "контроллером",
и представляет собой PHP-функцию, которая выполняет все необходимые действия
для того чтобы вернуть объект ``Response``, который будет отправлен пользователю.

Для того, чтобы сделать жизнь легче, вы можете отнаследоваться от базового класса 
``Controller``, который содержит методы для типичных задач, решаемых контроллером. 
Например, если вы не хотите вводить HTML код в свой контроллер, то вы можете 
использовать метод ``render()``, чтобы рендерить контент и вернуть его из шаблона.

В других главах вы узнаете как контроллер может быть использован для сохранения
и получения объектов из базы данных, обработки отправки форм, работы с кэшем
и многого другое.

Дополнительно в книге рецептов:
----------------------------

* :doc:`/cookbook/controller/error_pages`
* :doc:`/cookbook/controller/service`

.. toctree::
    :hidden:

    Translation source: n/a
    Corrected from: 2011-11-28 5cee7a0
    Corrected from: 
