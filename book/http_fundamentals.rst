.. index::
   single: Основы Symfony2

Symfony2 и основы HTTP
==============================

Поздравляем! Начав изучение Symfony2, вы встали на правильный путь, чтобы
стать более *продуктивным*, *всесторонне развитым* и *популярным* веб-разработчиком
(хотя последнее - на ваше усмотрение). Symfony2 создан, чтобы предоставлять базовые,
низкоуровневые инструменты, позволяющие вам разрабатывать быстрее, создавать более
надёжные приложения, но при этом не мешаться у вас под ногами. 
Symfony построен на лучших идеях, заимствованных из различных технологий: инструменты
и концепции, которые вы готовитесь изучить – представляют собой результаты работы тысяч и тысяч людей
на протяжении многих лет. Другими словами, вы не только изучаете "Symfony", вы изучаете
основы web, лучшие практики разработки, а также способы использования многих замечательных
PHP-библиотек в составе Symfony2 или не зависимо от него. Итак, приготовьтесь... 

Следуя философии Symfony2, эта глава начинается с объяснения основной концепции,
типичной для web-разработки: HTTP. Не зависимо от вашего опыта или любимого
языка программирования, эта глава **обязательна к прочтению** всем.

HTTP это Просто
--------------

HTTP (Hypertext Transfer Protocol или просто Протокол Передачи Гипертекста) - это
текстовый язык, позволяющий двум компьютерам обмениваться сообщениями друг с
другом. Вот и всё! Например, когда мы хотим посмотреть новенький комикс `xkcd`_,
имеет место (примерно) такой диалог:

.. image:: /images/http-xkcd.png
   :align: center

И хотя на самом деле используется более формальный язык, он остаётся предельно простым.
HTTP - это термин, используемый для описания этого простого текстового языка. И не важно,
как именно вы разрабатываете в web, целью вашего сервера *всегда* является понять
простой текстовый запрос и вернуть простой текстовый ответ.

Symfony2 полностью выстроен на этой реальности. Отдаете вы себе в этом отчет, или нет,
но HTTP - это то, что вы используете ежедневно. С помощью Symfony2 вы узнаете, как управлять им.

.. index::
   single: HTTP; Принцип запрос-ответ

Шаг 1: Клиент отправляет запрос
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Любой диалог в сети начинается с *запроса*. Запрос - это текстовое сообщение,
созданое клиентом (например браузером, iPhone приложением и т.д.) в особом
формате, также известном как HTTP. Клиент отправляет этот запрос серверу, и
ожидает ответ.

Взгляните на первую часть взаимодействия (запрос) между браузером и веб-сервером
xkcd:

.. image:: /images/http-xkcd-request.png
   :align: center

На языке HTTP этот запрос будет выглядеть примерно так:

.. code-block:: text

    GET / HTTP/1.1
    Host: xkcd.com
    Accept: text/html
    User-Agent: Mozilla/5.0 (Macintosh)

Это простое сообщение содержит *всю* необходимую информацию о том, какой
именно ресурс запрашивает клиент. Первая строка HTTP запроса наиболее
важна - она содержит 2 вещи: запрошенный URI и HTTP-метод.

URI (например ``/``, ``/contact``, и т.д.) - это уникальный адрес или место,
которое определяет запрошенный клиентом ресурс. HTTP-метод (например ``GET``)
определяет, что именно вы хотите сделать с запрошенным ресурсом. HTTP методы
это *глаголы* в запросе и они определяют несколько типичных путей, которыми
вы можете взаимодействовать с запрошенным ресурсом:

+----------+----------------------------+
| *GET*    | Получить ресурс с сервера  |
+----------+----------------------------+
| *POST*   | Создать ресурс на сервере  |
+----------+----------------------------+
| *PUT*    | Обновить ресурс на сервере |
+----------+----------------------------+
| *DELETE* | Удалить ресурс с сервера   |
+----------+----------------------------+

Запомнив эти типы HTTP-методов, вы можете представить себе, как будет
выглядеть HTTP-запрос на удаление определенной записи в блоге:

.. code-block:: text

    DELETE /blog/15 HTTP/1.1

.. note::

    На самом деле всего существует девять HTTP-методов, определённых в
    спецификации протокола HTTP, но многие из них не распространены
    или же ограниченно поддерживаются. К примеру, многие современные браузеры
    не поддерживают методы ``PUT`` и ``DELETE``.

В дополнение к первой строке, HTTP-запрос всегда содержит несколько
информационных строк, именуемых заголовками запроса (request headers). Заголовки могут
предоставлять различную информацию, такую как запрошенный ``Host``,
форматы ответа, которые поддерживает клиент (``Accept``) и приложение,
используемое клиентом для выполнения запроса (``User-Agent``). Существует
также много других заголовков, перечень которых вы можете найти в Википедии
на странице `List of HTTP header fields`_.

Шаг 2: Сервер возвращает ответ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Как только сервер получил запрос, он точно знает, какой ресурс нужен
клиенту (основываясь на URI) и что клиент хочет с этим ресурсом сделать - на
основании HTTP-метода. Например, в случае GET-запроса, сервер подготовит
запрошенный ресурс и возвратит его в виде HTTP-ответа. Рассмотрим ответ
от web сервера xkcd:

.. image:: /images/http-xkcd.png
   :align: center

Переведённый в формат HTTP, ответ, отправленный обратно браузеру, будет выглядеть
примерно так:

.. code-block:: text

    HTTP/1.1 200 OK
    Date: Sat, 02 Apr 2011 21:05:05 GMT
    Server: lighttpd/1.4.19
    Content-Type: text/html

    <html>
      <!-- HTML-код xkcd комикса -->
    </html>

HTTP-ответ содержит запрошенный ресурс (в данном случае это HTML-код страницы),
а также дополнительные данные о самом ответе. Первая строка особенно важна - она
содержит код состояния HTTP-ответа  (в данном случае 200). Код состояния сообщает 
о результате выполнения запроса, направляемом клиенту. Был ли запрос успешен? Была ли в ходе
выполнения запроса ошибка? Одни коды состояний обозначают успешные запросы, другие
- ошибки, третьи сообщают, что клиент хочет выполнить что-либо (например
перенаправление на другую страницу). Полный список вы можете найти странице
`List of HTTP status codes`_ в Википедии.

Подобно запросу, HTTP-ответ содержит дополнительную информацию, называемую
HTTP-заголовками. Например, важным заголовком HTTP-ответа является  ``Content-Type``.
Тело одного и того же ресурса может быть возвращено во множестве различных форматов,
включая HTML, XML или JSON, и заголовок ``Content-Type`` использует Типы Интернет 
Мультимедиа (Internet Media Types), в данном случае - ``text/html`` с тем, чтобы
сообщить клиенту, какой именно формат используется в данном ответе. Список
ниаболее распространённых типов можно найти в `List of common media types`_ Википедии.

Существует много различных заголовков, некоторые из них предоставляют большие
возможности. Например, некоторые заголовки могут быть использованы для
создания мощной системы кэширования.

Запросы, Ответы и Web-разработка
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Описанный обмен запросами-ответами - это фундаментальный процесс, который используется
для всех зваиможействий в web. И насколько важен этот процесс, настолько же он
прост.

Наиболее важным является следующий факт: вне зависимости от того, какой
язык программирования вы используете, какое приложение создаёте (web,
мобильное, JSON API) или какой философии следуете в разработке ПО,
конечной целью приложения **всегда** будет понять запрос и создать
соответствующий ответ.

Symfony спроектирована, таким образом, чтобы решать данную задачу.

.. tip::

    Для того чтобы узнать больше про спецификацию HTTP, прочитайте оригинал
    `HTTP 1.1 RFC`_ или же `HTTP Bis`_, который создан для разъяснения
    оригинальной спецификации. Замечательный инструмент для проверки заголовков
    запроса и ответа при работе в сети - это `Live HTTP Headers`_ расширение для Firefox.

.. index::
   single: Основы Symfony2; Запросы и ответы

Запросы и ответы в PHP
-----------------------------

Как же вы обрабатываете "запрос" и создаете "ответ" при использовании PHP?
На самом деле PHP немного абстрагирует вас от процесса::

    $uri = $_SERVER['REQUEST_URI'];
    $foo = $_GET['foo'];

    header('Content-type: text/html');
    echo 'The URI requested is: '.$uri;
    echo 'The value of the "foo" parameter is: '.$foo;

Как бы странно это ни звучало, но это крохотное приложение получает
информацию из HTTP-запроса и использует её для создания HTTP-ответа.
Вместо того, чтобы парсить необработанный HTTP-запрос, PHP подготавливает
суперглобальные переменные, такие как ``$_SERVER`` и ``$_GET``, которые содержат
всю информацию о запросе. Аналогично, вместо того, чтобы возвращать текст
ответа, форматированный по правилам HTTP, вы можете использовать функцию
``header()`` для создания заголовков ответов и просто вывести содержание страницы,
которое станет нужной частью ответа. PHP создаст реальный HTTP-ответ и вернет его клиенту:

.. code-block:: text

    HTTP/1.1 200 OK
    Date: Sat, 03 Apr 2011 02:14:33 GMT
    Server: Apache/2.2.17 (Unix)
    Content-Type: text/html

    Запрошенный URI: /testing?foo=symfony
    Значение параметра "foo": symfony

Запросы и ответы в Symfony
---------------------------------

Symfony предоставляет альтернативу стандартному подходу PHP, посредством двух
классов, которые позволяют упростить взаимодействие с HTTP-запросом и ответом
Класс :class:`Symfony\\Component\\HttpFoundation\\Request` - это простое
объектно-ориентированное представление HTTP-запроса. С его помощью можно
получить доступ к любой части информации HTTP-запроса::

    use Symfony\Component\HttpFoundation\Request;

    $request = Request::createFromGlobals();

    // запрошенный URI (например /about) без GET-переменных
    $request->getPathInfo();

    // получаем переменные GET и POST  соответственно
    $request->query->get('foo');
    $request->request->get('bar', 'default value if bar does not exist');
    
    // получаем переменные из массива $_SERVER
    $request->server->get('HTTP_HOST');

    // получаем экземпляр UploadedFile по идентификатору foo
    $request->files->get('foo');

    // получаем значения COOKIE
    $request->cookies->get('PHPSESSID');

    // получаем заголовоки HTTP-запроса используя нормализованные ключи в нижнем регистре
    $request->headers->get('host');
    $request->headers->get('content_type');

    $request->getMethod();          // GET, POST, PUT, DELETE, HEAD
    $request->getLanguages();       // массив языков, принимаемых клиентом

В качестве бонуса, класс ``Request`` выполняет большой объём скрытой работы,
так что вам не придется заботиться о многих вещах. Например, метод
``isSecure()`` проверяет *три* различных значения в PHP, которые указывают,
подключается ли пользователь  по защищенному протоколу (например HTTPS).

.. sidebar:: ParameterBag и атрибуты Request

    Как показано выше, переменные ``$_GET`` и ``$_POST`` доступны через
    public свойства ``query`` и ``request`` соотвественно. Оба свойства
    являются объектами класса :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`
    , содержащего методы
    :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::get`,
    :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::has`,
    :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::all` и так далее.
    На самоме деле, каждое public свойство, использованное в предыдущем примере
    является экемпляром ParameterBag или его дочерним классом.
    
    .. _book-fundamentals-attributes:

    Класс Request также обладает public свойством ``attributes``, содержащим
    специальные данные используемые приложением. В рамках Symfony2
    ``attributes`` содержит значения, текущего совпавшего маршрута,
    такие как, ``_controller``, ``id`` (если маршрут сожержит плейсхолдер ``{id}``),
    и даже имя совпавшего маршрута (``_route``). Свойство ``attributes`` было
    целиком создано для того, чтобы быть хранить контексто-зависимую информацию  о запросе.
    

Symfony также предоставляет класс ``Response``: простое РHP-представление
HTTP-ответа. Это позволяет вашему приложению использовать объектно-ориентированный
интерфейс для построения ответа, который нужно вернуть клиенту::

    use Symfony\Component\HttpFoundation\Response;
    $response = new Response();

    $response->setContent('<html><body><h1>Hello world!</h1></body></html>');
    $response->setStatusCode(200);
    $response->headers->set('Content-Type', 'text/html');

    // выводит заголовки HTTP и содержание
    $response->send();

Даже если бы Symfony ничего больше вам не предлагала, у вас уже был бы набор
инструментов для того, чтобы можно было просто и быстро получить доступ к информации
запроса и объектно-ориентированный интерфейс для создания ответа. Даже
если вы освоите более мощные возможности Symfony, всегда помните, что цель
вашего приложения всегда заключается в том, чтобы *интерпретировать
запрос и создать соответствующий ответ, основываясь на логике вашего приложения*

.. tip::

    Классы ``Request`` и ``Response`` являются частью самостоятельного
    компонента Symfony, называемого ``HttpFoundation``. Этот компонент
    может быть использован независимо от Symfony, а также он предоставляет
    классы для работы с сессией и загрузкой файлов.

Путешествие от Запроса к Ответу
--------------------------------------------

Как и HTTP-протокол, объекты ``Request`` и ``Response`` достаточно просты.
Самая сложная часть создания приложения заключается в описании того, что
происходят между ними. Другими словами, реальная работа заключается в
написании кода, который интерпретирует информацию запроса и создает ответ.

Ваше приложение может иметь много функций, например, отправлять письма,
обрабатывать отправленные формы, сохранять что-то в базу данных, подготавливать
HTML-страницы и защищать содержимое правилами безопасности. Как управлять всем
этим и при этом сохранить код хорошо организованным и поддерживаемым?

Symfony создана специально для решения этих проблем за вас.

Фронт-контроллер
~~~~~~~~~~~~~~~~~~~~

Обычно приложения создавались таким образом, чтобы каждая "страница"
имела свой собственный файл:

.. code-block:: text

    index.php
    contact.php
    blog.php

При таком подходе имеется целый ряд проблем, включая жёсткие URLы (что если
вам потребуется изменить ``blog.php`` на ``news.php`` и при этом сохранить
все ваши ссылки?), а также необходимость вручную подключать каждый раз
набор файлов таким образом, чтобы безопасность, связь с базами данных и
"внешний вид" сайта могли сохранять свою целостность.

Более удачным является подход с использованием :term:`front controller`,
единственного PHP-файла, который обрабатывает каждый запрос к вашему приложению.
Например:

+------------------------+-------------------------+
| ``/index.php``         | выполняет ``index.php`` |
+------------------------+-------------------------+
| ``/index.php/contact`` | выполняет ``index.php`` |
+------------------------+-------------------------+
| ``/index.php/blog``    | выполняет ``index.php`` |
+------------------------+-------------------------+

.. tip::

    Используя модуль Apache ``mod_rewrite``  (или эквивалента для других
    web-серверов) URLы можно легко привести к формату ``/``, ``/contact`` и ``/blog``.

Теперь, каждый запрос обрабатывается одинакого. Вместо того, чтобы
каждый отдельный URL запускал различные PHP-файлы - фронт-контроллер выполняется
*всегда* и связь различных URLов с частями вашего приложения производится
самим приложением. Это решает обе проблемы традиционного подхода.
Практически все современные web-приложения используют этот подход,
включая приложения типа WordPress.

Будьте организованы
~~~~~~~~~~~~~~

Внутри вашего фронт-контроллера, вам нужно определить какой код нужно выполнить
и какое должно быть содержание ответа. Для того чтобы сделать это вам нужно
обработать входящий URI и выполнить соответствуюие его значению части вашего кода.
Простой и весьма уродливый вариант::

    // index.php
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\HttpFoundation\Response;
    $request = Request::createFromGlobals();
    $path = $request->getPathInfo(); // запрошенный URL

    if (in_array($path, array('', '/')) {
        $response = new Response('Welcome to the homepage.');
    } elseif ($path == '/contact') {
        $response = new Response('Contact us');
    } else {
        $response = new Response('Page not found.', 404);
    }
    $response->send();

Решение данной задачи может быть достаточно сложным. К счастью, Symfony создана
*именно* для этого.

Как устроено Symfony приложение
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Когда вы даёте возможность Symfony обрабатывать запросы, жизнь становится много
проще. Symfony следует простому шаблону при обработке каждого запроса:

.. _request-flow-figure:

.. figure:: /images/request-flow.png
   :align: center
   :alt: Symfony2 request flow

   Входящие запросы интерпретируются маршрутизатором и передаются в
   функцию-контроллер, которая возвращает объекты ``Response``.

Каждая "страница" вашего сайта должна быть определена в конфигурации
маршрутизатора, чтобы распределять различные URL по различным PHP-функциям.
Обязанность каждой такой функции, называемой :term:`controller`, используя
информацию из запроса - а также используя прочий инструментарий, доступный в
Symfony, создать и вернуть объект ``Response``. Другими словами, контроллер
содержит *ваш* код: именно там вы должны превратить запрос в ответ.

Это не сложно! Давайте-ка взглянем:

* Каждый запрос обрабатывается фронт-контроллером;

* Система маршрутизации определяет, какую именно PHP-функцию необходимо
  выполнить, основываясь на информации из запроса и конфигурации маршрутизатора,
  которую вы создали;

* Вызывается необходимая PHP функция, в которой написанный вами код создаёт и возвращает
  соответствующий объект ``Response``.

Symfony Request в действии
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Не проникая глубоко в детали, давайте посмотрим на этот процесс в действии.
Предположим, вы хотите добавить страницу ``/contact`` в ваше Symfony приложение.
Во-первых, надо добавить конфигурацию маршрутизатора для пути ``/contact``

.. configuration-block::

    .. code-block:: yaml

        # app/config/routing.yml
        contact:
            path:     /contact
            defaults: { _controller: AcmeDemoBundle:Main:contact }

    .. code-block:: xml

        <?xml version="1.0" encoding="UTF-8" ?>
        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing
                http://symfony.com/schema/routing/routing-1.0.xsd">

            <route id="contact" path="/contact">
                <default key="_controller">AcmeDemoBundle:Main:contact</default>
            </route>
        </routes>

    .. code-block:: php

        // app/config/routing.php
        use Symfony\Component\Routing\RouteCollection;
        use Symfony\Component\Routing\Route;

        $collection = new RouteCollection();
        $collection->add('contact', new Route('/contact', array(
            '_controller' => 'AcmeDemoBundle:Main:contact',
        )));

        return $collection;

.. note::

   Этот пример использует :doc:`YAML</components/yaml/yaml_format>` для того чтобы определить
   конфигурацию маршрутизатора. Конфигурацию можно также задавать и в других
   форматах - таких как XML или PHP.

Когда кто-либо заходит на страницу ``/contact``, определяется данный маршрут и
указанный контроллер выполняется. Как вы узнаете в из главы :doc:`Маршрутизация</book/routing>`,
строка ``AcmeDemoBundle:Main:contact`` это короткая форма записи, которая указывает на
особый РНР метод ``contactAction``, определённый в классе ``MainController``::

    // src/Acme/DemoBundle/Controller/MainController.php
    namespace Acme\DemoBundle\Controller;

    use Symfony\Component\HttpFoundation\Response;

    class MainController
    {
        public function contactAction()
        {
            return new Response('<h1>Contact us!</h1>');
        }
    }

В этом простом примере, контроллер создает объект
:class:`Symfony\\Component\\HttpFoundation\\Response`,
содержащий HTML-код ``<h1>Contact us!</h1>``. В главе
:doc:`Контроллер</book/controller>`, вы узнаете, как контроллер может
обрабатывать шаблоны, позволяя "презентационному" коду (т.е. всему, что
реально генерирует HTML) существовать в отдельном файле-шаблоне. Это
овобождает контроллер для работы с более сложными задачами: взаимодействия
с базами данных, обработки отправленных пользователем данных или
отправки email сообщений.

Symfony2: Создавайте приложение, а не инструменты.
-----------------------------------------

Теперь вы знаете, что цель любого приложения заключается в интерпретации
входящих запросов и создании соответствующего ответа. По мере роста
приложения становится труднее подддерживать код организованным. Без сомнений,
одни и те же сложные задачи будут повторяться снова и снова: сохранение данных в базу,
генерирование и повторное использование шаблонов, обработка форм, отправка писем,
валидация данных, введённых пользователем и безопасность.

Хорошие новости заключаются в том, что эти проблемы не уникальны. Symfony
предоставляет пакет, полный инструментов, которые позволят вам создавать
ваше приложение, а не ваши инструменты. При этом Symfony2 вам ничего
не навязывает: вы можете использовать как весь пакет Symfony, так и какую-то его
часть.

.. index::
   single: Symfony2 Components

Автономные библиотеки: *Компоненты* Symfony2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Так что же *представляет собой*  Symfony2? Прежде всего, Symfony2 - это коллекция
более чем 20 независимых библиотек, которые могут быть использованы *в любом*
PHP-проекте. Эти библиотеки, называемые *Symfony2 Components*, содержат полезные
решения практически на любой случай жизни, не зависимо от того как именно ваш проект
разрабатывается. Вот некоторые из них:

* :doc:`HttpFoundation </components/http_foundation/introduction>`_ - Содержит классы 
   ``Request`` и ``Response``, а также классы для работы с сессиями и загрузкой файлов;

* :doc:`Routing </components/routing/introduction>` - мощная и быстрая система маршрутизации, 
  которая позволяет сопоставить заданный URI (например ``/contact``) информацию
  о том, как этот запрос должен быть обработан (например вызвать метод ``contactAction()``);

* `Form`_ - многофункциональный и гибкий пакет для создания форм и обработки результатов их
  заполнения;

* `Validator`_ - система, предназначенная для создания правил для данных
  и последующей валидации - соответствуют ли данные, отправленные пользователями
  этим правилам;

* :doc:`ClassLoader </components/class_loader/introduction>` - библиотека автозагрузок, позволяющая
  использовать PHP-классы без необходимости вручную ``подключать`` файлы, содержащие эти классы.

* :doc:`Templating </components/templating/introduction>` - набор инструментов для обработки
  шаблонов,  поддерживает наследование шаблонов (т.е. декорирование шаблонов при помощи
  родительского), а также прочие типичные для шаблонов операции;

* `Security`_ мощная библиотека для обеспечения всех типов безопасности
  внутри приложения;

* `Translation`_ - пакет для перевода строк в вашем приложении.

Каждый из этих компонентов независим и может быть использован в *любом*
PHP-проекте, не зависимо от Symfony2. Каждая часть может быть использована
либо заменена при необходимости.

Комплексное решение: Symfony2 *Framework*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ну так что же это *такое* - Symfony2 *Framework*? *Symfony2 Framework*
это PHP библиотека, которая решает 2 отдельные задачи:

#. Предоставляет набор компонентов (т.е. Symfony2 Components) и
   сторонних библиотек (например ``Swiftmailer`` для отправки почты);

#. Предоставляет возможность конфигурирования и библиотеку для связывания всех
   компонентов в единое целое.

Цель фреймворка - интеграция множества независимых инструментов, для того чтобы обеспечить
целостное решение для разработчика. Даже сам по себе фреймворк - это тоже Symfony2 бандл
(т.е. плагин), который можно конфигурировать или даже заменить полностью.

Symfony2 предоставляет мощный набор инструментов для быстрой разработки
web-приложений, ничего не навязывающий непосредственно вашему приложению.
Разработчик может быстро приступить к разработке, используя дистрибутив Symfony2,
который предоставляет скелет проекта с типовыми настройками. А для более опытных ползователей
нет пределов совершенству.

.. _`xkcd`: http://xkcd.com/
.. _`HTTP 1.1 RFC`: http://www.w3.org/Protocols/rfc2616/rfc2616.html
.. _`HTTP Bis`: http://datatracker.ietf.org/wg/httpbis/
.. _`Live HTTP Headers`: https://addons.mozilla.org/en-US/firefox/addon/live-http-headers/
.. _`List of HTTP status codes`: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
.. _`List of HTTP header fields`: http://en.wikipedia.org/wiki/List_of_HTTP_header_fields
.. _`List of common media types`: http://en.wikipedia.org/wiki/Internet_media_type#List_of_common_media_types
.. _`Form`: https://github.com/symfony/Form
.. _`Validator`: https://github.com/symfony/Validator
.. _`Security`: https://github.com/symfony/Security
.. _`Translation`: https://github.com/symfony/Translation
.. _`Swift Mailer`: http://swiftmailer.org/
